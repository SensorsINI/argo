// SPDX-License-Identifier: GPL-2.0
// DTS for Argo Radio Servo Module Overlay on Orange Pi Zero 2W (Allwinner H618)
// This overlay configures EINT input pins and explicitly defines PWM channels 2 and 4
// for control via the kernel's generic PWM API (pwm_get).

#include <dt-bindings/interrupt-controller/irq.h>
#include <dt-bindings/interrupt-controller/arm-gic.h>
#include <dt-bindings/gpio/gpio.h> // For GPIO_ACTIVE_HIGH/LOW, etc.


/dts-v1/;
/plugin/;

/ {
    compatible = "xunlong,orangepi-zero2w", "allwinner,sun50i-h618";

    // Node for our kernel module to claim GPIOs (using compatible for lookup)
    // This node now also controls the pin multiplexing for the EINT pins.
    argo_radio_servo_gpios: argo_radio_servo_gpios {
        compatible = "argo,radio-servo-gpio";
        radio_rudder_gpio = <&pio 8 11 GPIO_ACTIVE_HIGH>; // PI11
        radio_sail_gpio = <&pio 8 13 GPIO_ACTIVE_HIGH>;   // PI13
        pinctrl-names = "default";
        pinctrl-0 = <&pi11_eint_pulse_in_group>,
                    <&pi13_eint_pulse_in_group>;
        status = "okay";
    };

    // --- Fragment 0: Explicitly disable the Ethernet GMAC controller itself ---
    frag_emac_disable: fragment@0 {
        target = <&emac1>;
        __overlay__ {
            status = "disabled";
        };
    };

    // --- Fragment 1: Define our specific EINT pin groups as children of &pio ---
    // This fragment now ONLY adds the pin group nodes to the pio controller.
    // It does NOT modify the pio controller's own properties, which was the
    // source of the i2c0 conflict.
    frag_eint_pins: fragment@1 {
        target = <&pio>; // Target the main pinctrl node (&pio == pinctrl@300b000)
        __overlay__ {
            // PI11 (PWM1_RADIO_RUDDER) - Input (EINT function)
            pi11_eint_pulse_in_group: pi11_eint_pulse_in_group {
                pins = "PI11";
                function = "pi_eint11"; // EINT function for PI11
            };

            // PI13 (PWM3_RADIO_SAIL) - Input (EINT function)
            pi13_eint_pulse_in_group: pi13_eint_pulse_in_group {
                pins = "PI13";
                function = "pi_eint13"; // EINT function for PI13
            };
        };
    };

    // following commented out because we use armbian pwm output overlay instead
    // --- Fragment 3: Define PWM Output Pinmuxing Groups for PI12 and PI14 ---
    /* fragment@3 {
        target = <&pio>; // Target the main pinctrl node
        __overlay__ {
            // PI12 (PWM2_SERVO_RUDDER) - Output
            pi12_pwm2_out_group: pi12_pwm2_out_group {
                pins = "PI12";
                function = "pwm2"; // As per manual's PI12_SELECT (101:PWM2)
            };

            // PI14 (PWM4_SERVO_SAIL) - Output
            pi14_pwm4_out_group: pi14_pwm4_out_group {
                pins = "PI14";
                function = "pwm4"; // As per manual's PI14_SELECT (101:PWM4)
            };
        };
    };
    */
};
